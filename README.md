# canvasCache
Android绘图中的双缓冲
我们知道，我们在绘图时有两样东西是少不了的，一个是Canvas（画布），一个是Paint(画笔）。

Canvas提供画各种图形的方法，如画圆（drawCircle)，画矩形（drawRect）等等，Paint用来设置画笔的样式，比如笔的粗细，颜色等。每个Canvas内部持有一个Bitmap对象的引用，画图的过程其实就是往这个Bitmap当中写入ARGB信息。

比如我们现在自定义一个View,在上面画一个矩形和一个圆：

那么现在有一个问题，画矩形和画圆是两个独立的动作，会不会在drawRect执行完之后屏幕上马上就会显示出来一个矩形呢？

为了验证我们的猜想，我们在两个绘图动作中加一个sleep:

我们会看到，并不是先显示矩形再显示圆，而是两个几乎同时一起显示出来的。这就说明必须要等onDraw方法执行完成之后，才会把数据交给GPU去处理展示。这就是android绘图当中的第一道缓冲，即显示缓冲区。

而所谓的双缓冲，在android绘图中其实就是再创建一个Canvas和对应的Bitmap，然后在onDraw方法里默认的Canvas通过drawBitmap画刚才new的那个bitmap从而实现双缓冲。

双缓冲绘图的优缺点及适用场景

我们通过一个例子来说明。

实现这样一个功能，一个自定义View,每次点击的时候在点击处画一个圆。我们先不使用双缓冲来实现：


在绘制数据量较小时，不使用双缓冲，GPU的负荷更低，即绘制性能更高；
在绘制数据量较大时，使用双缓冲绘图，绘制性能明显高于不使用双缓冲的情况；
使用双缓冲会增加内存消耗。
其实上面的结论也很好理解，就像上面举的搬砖的例子，如果砖少的话，用车来拉明显是划不来的，砖的数量很多的时候，用车来拉就可以节省很多时间，但是用车就要消耗额外的资源，这就需要根据不同的情况做出正确的选择。
